Object-Oriented Programming (OOP) is a programming paradigm that uses objects, which are instances of classes, to design and organize code. OOP is based on several fundamental concepts that help structure code, promote reusability, and improve maintainability. Here are the core OOP concepts:

1. **Class:**
   - A class is a blueprint or template for creating objects.
   - It defines a set of attributes (properties) and methods (functions) that the objects created from the class will have.

2. **Object:**
   - An object is an instance of a class.
   - It represents a real-world entity and encapsulates both data (attributes) and behavior (methods).
   - Objects are created from classes and can interact with each other.

3. **Encapsulation:**
   - Encapsulation refers to bundling the data (attributes) and methods that operate on the data within a single unit, i.e., a class.
   - It hides the internal details of how the object works and exposes only what is necessary.

4. **Inheritance:**
   - Inheritance allows a class (subclass or derived class) to inherit properties and methods from another class (superclass or base class).
   - It promotes code reuse and establishes a relationship between classes.

5. **Polymorphism:**
   - Polymorphism allows objects of different classes to be treated as objects of a common base class.
   - It enables a single interface to represent different types, and it can take different forms: compile-time (method overloading) and runtime (method overriding).

6. **Abstraction:**
   - Abstraction involves simplifying complex systems by modeling classes based on the essential features and ignoring unnecessary details.
   - It provides a clear separation between what an object does and how it achieves its functionality.


the syntax examples for Object-Oriented Programming (OOP) concepts in C#:

### 1. Class:

```csharp
class Car
{
    public string Make { get; set; }
    public string Model { get; set; }

    public Car(string make, string model)
    {
        Make = make;
        Model = model;
    }

    // Other methods can be added here
}
```

### 2. Object:

```csharp
// Creating objects from the Car class
Car car1 = new Car("Toyota", "Camry");
Car car2 = new Car("Honda", "Accord");

// Accessing object properties
Console.WriteLine(car1.Make);  // Output: Toyota
Console.WriteLine(car2.Model); // Output: Accord
```

### 3. Encapsulation:

```csharp
class Student
{
    private string name;  // Private field
    private int age;      // Private field

    public Student(string name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public string GetName()
    {
        return name;
    }

    public void SetAge(int age)
    {
        if (age > 0)
        {
            this.age = age;
        }
    }
}

// Accessing private members through public methods
Student student = new Student("Alice", 20);
Console.WriteLine(student.GetName());  // Output: Alice
student.SetAge(21);
```

### 4. Inheritance:

```csharp
class Animal
{
    public virtual string Speak()
    {
        return "Generic animal sound";
    }
}

class Dog : Animal
{
    public override string Speak()
    {
        return "Woof!";
    }
}

class Cat : Animal
{
    public override string Speak()
    {
        return "Meow!";
    }
}

// Using inheritance
Animal animal = new Animal();
Console.WriteLine(animal.Speak());  // Output: Generic animal sound

Dog dog = new Dog();
Console.WriteLine(dog.Speak());     // Output: Woof!

Cat cat = new Cat();
Console.WriteLine(cat.Speak());     // Output: Meow!
```

### 5. Polymorphism:

```csharp
// Compile-time polymorphism (method overloading)
class MathOperations
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
}

// Runtime polymorphism (method overriding)
class Bird
{
    public virtual string Fly()
    {
        return "Can fly";
    }
}

class Penguin : Bird
{
    public override string Fly()
    {
        return "Can't fly";
    }
}

// Using polymorphism
MathOperations mathOps = new MathOperations();
int result1 = mathOps.Add(1, 2);         // Calls the first Add method
int result2 = mathOps.Add(1, 2, 3);      // Calls the second Add method
Console.WriteLine(result1);  // Output: 3
Console.WriteLine(result2);  // Output: 6

Bird bird = new Bird();
Console.WriteLine(bird.Fly());     // Output: Can fly

Penguin penguin = new Penguin();
Console.WriteLine(penguin.Fly());  // Output: Can't fly
```

### 6. Abstraction:

```csharp
// Using abstraction
abstract class Shape
{
    public abstract double Area();
}

class Circle : Shape
{
    private double radius;

    public Circle(double radius)
    {
        this.radius = radius;
    }

    public override double Area()
    {
        return 3.14 * radius * radius;
    }
}

// Creating objects from the Circle class
Circle circle = new Circle(5);
Console.WriteLine(circle.Area());  // Output: 78.5
```
